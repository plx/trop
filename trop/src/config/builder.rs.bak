//! Configuration builder pattern.
//!
//! This module provides a builder for constructing configurations programmatically,
//! integrating file loading, merging, environment variables, and validation.

use crate::config::environment::EnvironmentConfig;
use crate::config::loader::{ConfigLoader, ConfigSource};
use crate::config::merger::ConfigMerger;
use crate::config::schema::{
    CleanupConfig, Config, OccupancyConfig, OutputFormat, PortConfig, PortExclusion,
};
use crate::config::validator::ConfigValidator;
use crate::error::Result;
use std::path::{Path, PathBuf};

/// Builder for loading and constructing configuration.
///
/// # Examples
///
/// ```no_run
/// use trop::config::ConfigBuilder;
/// use std::path::Path;
///
/// let config = ConfigBuilder::new()
///     .with_working_dir(Path::new("."))
///     .build()
///     .unwrap();
/// ```
pub struct ConfigBuilder {
    working_dir: Option<PathBuf>,
    skip_env: bool,
    skip_files: bool,
    additional_config: Option<Config>,
}

impl ConfigBuilder {
    /// Create a new configuration builder.
    #[must_use]
    pub fn new() -> Self {
        Self {
            working_dir: None,
            skip_env: false,
            skip_files: false,
            additional_config: None,
        }
    }

    /// Set the working directory for config discovery.
    ///
    /// Configuration files will be discovered starting from this directory
    /// and walking up the directory tree.
    #[must_use]
    pub fn with_working_dir(mut self, dir: impl AsRef<Path>) -> Self {
        self.working_dir = Some(dir.as_ref().to_path_buf());
        self
    }

    /// Skip loading configuration files.
    ///
    /// Useful for testing or when you want to build configuration programmatically.
    #[must_use]
    pub fn skip_files(mut self) -> Self {
        self.skip_files = true;
        self
    }

    /// Skip environment variable overrides.
    ///
    /// Useful for testing or when you want deterministic configuration.
    #[must_use]
    pub fn skip_env(mut self) -> Self {
        self.skip_env = true;
        self
    }

    /// Add additional configuration to merge (highest precedence).
    ///
    /// This configuration will be merged last, giving it the highest precedence
    /// after environment variables.
    #[must_use]
    pub fn with_config(mut self, config: Config) -> Self {
        self.additional_config = Some(config);
        self
    }

    /// Build the final configuration.
    ///
    /// Performs the following steps:
    /// 1. Starts with default configuration
    /// 2. Loads and merges file-based configurations (if not skipped)
    /// 3. Applies environment variable overrides (if not skipped)
    /// 4. Applies additional configuration (if provided)
    /// 5. Validates the final configuration
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Configuration files cannot be read or parsed
    /// - Environment variables contain invalid values
    /// - The final configuration fails validation
    pub fn build(self) -> Result<Config> {
        let mut sources = Vec::new();

        // Load configuration files
        if !self.skip_files {
            let working_dir = self
                .working_dir
                .as_deref()
                .unwrap_or_else(|| Path::new("."));
            sources = ConfigLoader::load_all(working_dir)?;
        }

        // Add default configuration at lowest precedence
        sources.insert(
            0,
            ConfigSource {
                path: PathBuf::from("<defaults>"),
                precedence: 0,
                config: Self::default_config(),
            },
        );

        // Merge all file-based configs
        let mut config = ConfigMerger::merge(sources.clone());

        // Apply environment overrides
        if !self.skip_env {
            EnvironmentConfig::apply_overrides(&mut config)?;
        }

        // Apply additional config if provided
        if let Some(additional) = self.additional_config {
            ConfigMerger::merge_into(&mut config, &additional);
        }

        // Validate final configuration
        let is_tropfile = sources.iter().any(|s| {
            s.path
                .file_name()
                .and_then(|n| n.to_str())
                .is_some_and(|n| n == "trop.yaml" || n == "trop.local.yaml")
        });

        ConfigValidator::validate(&config, is_tropfile)?;

        Ok(config)
    }

    /// Create default configuration.
    ///
    /// Returns a configuration with all defaults matching the specification:
    /// - Port range: 5000-7000
    /// - Expire after: 30 days
    /// - Lock timeout: 5 seconds
    /// - All auto behaviors enabled
    /// - All permission flags disabled
    /// - All occupancy checks enabled
    /// - Output format: table
    fn default_config() -> Config {
        Config {
            project: None,
            ports: Some(PortConfig {
                min: 5000,
                max: Some(7000),
                max_offset: None,
            }),
            excluded_ports: None,
            cleanup: Some(CleanupConfig {
                expire_after_days: Some(30),
            }),
            occupancy_check: Some(OccupancyConfig {
                skip: Some(false),
                skip_ip4: Some(false),
                skip_ip6: Some(false),
                skip_tcp: Some(false),
                skip_udp: Some(false),
                check_all_interfaces: Some(false),
            }),
            reservations: None,
            disable_autoinit: Some(false),
            disable_autoprune: Some(false),
            disable_autoexpire: Some(false),
            allow_unrelated_path: Some(false),
            allow_change_project: Some(false),
            allow_change_task: Some(false),
            allow_change: Some(false),
            maximum_lock_wait_seconds: Some(5),
            output_format: Some(OutputFormat::Table),
        }
    }
}

impl Default for ConfigBuilder {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_builder_default() {
        let config = ConfigBuilder::new().skip_files().build().unwrap();

        // Check all defaults
        assert_eq!(config.ports.as_ref().unwrap().min, 5000);
        assert_eq!(config.ports.as_ref().unwrap().max, Some(7000));
        assert_eq!(config.cleanup.as_ref().unwrap().expire_after_days, Some(30));
        assert_eq!(config.maximum_lock_wait_seconds, Some(5));
        assert_eq!(config.disable_autoinit, Some(false));
        assert_eq!(config.output_format, Some(OutputFormat::Table));
    }

    #[test]
    fn test_builder_skip_files() {
        let config = ConfigBuilder::new().skip_files().build().unwrap();
        assert!(config.project.is_none());
    }

    #[test]
    fn test_builder_with_working_dir() {
        let temp_dir = TempDir::new().unwrap();
        fs::write(temp_dir.path().join("trop.yaml"), "project: test-project\n").unwrap();

        let config = ConfigBuilder::new()
            .with_working_dir(temp_dir.path())
            .skip_env()
            .build()
            .unwrap();

        assert_eq!(config.project, Some("test-project".to_string()));
    }

    #[test]
    fn test_builder_with_additional_config() {
        let additional = Config {
            project: Some("override".to_string()),
            ..Default::default()
        };

        let config = ConfigBuilder::new()
            .skip_files()
            .skip_env()
            .with_config(additional)
            .build()
            .unwrap();

        assert_eq!(config.project, Some("override".to_string()));
    }

    #[test]
    fn test_builder_validates() {
        let invalid = Config {
            project: Some("".to_string()), // Empty project name
            ..Default::default()
        };

        let result = ConfigBuilder::new()
            .skip_files()
            .skip_env()
            .with_config(invalid)
            .build();

        assert!(result.is_err());
    }

    #[test]
    fn test_builder_precedence_order() {
        let temp_dir = TempDir::new().unwrap();

        // File says project=file
        fs::write(temp_dir.path().join("trop.yaml"), "project: file\n").unwrap();

        // Additional config says project=override
        let additional = Config {
            project: Some("override".to_string()),
            ..Default::default()
        };

        let config = ConfigBuilder::new()
            .with_working_dir(temp_dir.path())
            .skip_env()
            .with_config(additional)
            .build()
            .unwrap();

        // Additional config should win
        assert_eq!(config.project, Some("override".to_string()));
    }

    #[test]
    fn test_builder_merges_excluded_ports() {
        let temp_dir = TempDir::new().unwrap();

        // File excludes 5001
        fs::write(
            temp_dir.path().join("trop.yaml"),
            "excluded_ports:\n  - 5001\n",
        )
        .unwrap();

        // Additional config excludes 5002
        let additional = Config {
            excluded_ports: Some(vec![PortExclusion::Single(5002)]),
            ..Default::default()
        };

        let config = ConfigBuilder::new()
            .with_working_dir(temp_dir.path())
            .skip_env()
            .with_config(additional)
            .build()
            .unwrap();

        // Both should be present
        assert_eq!(config.excluded_ports.as_ref().unwrap().len(), 2);
    }

    #[test]
    fn test_default_config_matches_spec() {
        let defaults = ConfigBuilder::default_config();

        // Port range
        let ports = defaults.ports.unwrap();
        assert_eq!(ports.min, 5000);
        assert_eq!(ports.max, Some(7000));

        // Cleanup
        let cleanup = defaults.cleanup.unwrap();
        assert_eq!(cleanup.expire_after_days, Some(30));

        // Lock timeout
        assert_eq!(defaults.maximum_lock_wait_seconds, Some(5));

        // Auto behaviors
        assert_eq!(defaults.disable_autoinit, Some(false));
        assert_eq!(defaults.disable_autoprune, Some(false));
        assert_eq!(defaults.disable_autoexpire, Some(false));

        // Permissions
        assert_eq!(defaults.allow_unrelated_path, Some(false));
        assert_eq!(defaults.allow_change_project, Some(false));
        assert_eq!(defaults.allow_change_task, Some(false));
        assert_eq!(defaults.allow_change, Some(false));

        // Occupancy checks
        let occ = defaults.occupancy_check.unwrap();
        assert_eq!(occ.skip, Some(false));
        assert_eq!(occ.skip_ip4, Some(false));
        assert_eq!(occ.skip_ip6, Some(false));
        assert_eq!(occ.skip_tcp, Some(false));
        assert_eq!(occ.skip_udp, Some(false));
        assert_eq!(occ.check_all_interfaces, Some(false));

        // Output format
        assert_eq!(defaults.output_format, Some(OutputFormat::Table));
    }
}
