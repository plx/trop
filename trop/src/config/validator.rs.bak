//! Configuration validation.
//!
//! This module provides comprehensive validation for all configuration fields,
//! ensuring that values are valid and consistent.

use crate::config::schema::{
    CleanupConfig, Config, PortConfig, PortExclusion, ReservationGroup, ServiceDefinition,
};
use crate::error::{Error, Result};
use crate::port::Port;
use std::collections::HashSet;

/// Validates configuration according to spec rules.
///
/// # Examples
///
/// ```
/// use trop::config::{Config, ConfigValidator};
///
/// let config = Config::default();
/// ConfigValidator::validate(&config, false).unwrap();
/// ```
pub struct ConfigValidator;

impl ConfigValidator {
    /// Validate a complete configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - The configuration to validate
    /// * `is_tropfile` - Whether this is from a trop.yaml file (affects which fields are allowed)
    ///
    /// # Errors
    ///
    /// Returns validation errors for invalid configurations.
    pub fn validate(config: &Config, is_tropfile: bool) -> Result<()> {
        // Validate project field (only in trop.yaml)
        if let Some(ref project) = config.project {
            if !is_tropfile {
                return Err(Error::Validation {
                    field: "project".into(),
                    message: "project field is only valid in trop.yaml files".into(),
                });
            }
            Self::validate_identifier("project", project)?;
        }

        // Validate reservations (only in trop.yaml)
        if let Some(ref reservations) = config.reservations {
            if !is_tropfile {
                return Err(Error::Validation {
                    field: "reservations".into(),
                    message: "reservations field is only valid in trop.yaml files".into(),
                });
            }
            Self::validate_reservation_group(reservations)?;
        }

        // Validate port configuration
        if let Some(ref ports) = config.ports {
            Self::validate_port_config(ports)?;
        }

        // Validate excluded ports
        if let Some(ref excluded) = config.excluded_ports {
            Self::validate_excluded_ports(excluded)?;
        }

        // Validate cleanup config
        if let Some(ref cleanup) = config.cleanup {
            Self::validate_cleanup(cleanup)?;
        }

        // Validate lock timeout
        if let Some(timeout) = config.maximum_lock_wait_seconds {
            if timeout == 0 {
                return Err(Error::Validation {
                    field: "maximum_lock_wait_seconds".into(),
                    message: "Timeout must be greater than 0".into(),
                });
            }
        }

        Ok(())
    }

    /// Validate string identifiers (project, task, tags).
    ///
    /// Checks that the identifier is non-empty after trimming, contains no
    /// null bytes, and is not longer than 255 characters.
    fn validate_identifier(field: &str, value: &str) -> Result<()> {
        let trimmed = value.trim();

        if trimmed.is_empty() {
            return Err(Error::Validation {
                field: field.into(),
                message: "Cannot be empty or only whitespace".into(),
            });
        }

        // Additional checks for security/safety
        if trimmed.contains('\0') {
            return Err(Error::Validation {
                field: field.into(),
                message: "Cannot contain null bytes".into(),
            });
        }

        if trimmed.len() > 255 {
            return Err(Error::Validation {
                field: field.into(),
                message: "Cannot exceed 255 characters".into(),
            });
        }

        Ok(())
    }

    /// Validate port configuration.
    ///
    /// Ensures min and max are valid ports, max >= min, and that max and
    /// `max_offset` are not both specified.
    fn validate_port_config(config: &PortConfig) -> Result<()> {
        // Validate min port
        Port::try_from(config.min).map_err(|_| Error::Validation {
            field: "ports.min".into(),
            message: format!("Invalid port number: {}", config.min),
        })?;

        // Validate max if present
        if let Some(max) = config.max {
            Port::try_from(max).map_err(|_| Error::Validation {
                field: "ports.max".into(),
                message: format!("Invalid port number: {max}"),
            })?;

            if max < config.min {
                return Err(Error::Validation {
                    field: "ports".into(),
                    message: "max must be >= min".into(),
                });
            }
        }

        // Validate max_offset if present
        if let Some(offset) = config.max_offset {
            if offset == 0 {
                return Err(Error::Validation {
                    field: "ports.max_offset".into(),
                    message: "max_offset must be > 0".into(),
                });
            }

            let computed_max = config.min.saturating_add(offset);
            Port::try_from(computed_max).map_err(|_| Error::Validation {
                field: "ports.max_offset".into(),
                message: format!("Offset would create invalid max port: {computed_max}"),
            })?;
        }

        // Can't have both max and max_offset
        if config.max.is_some() && config.max_offset.is_some() {
            return Err(Error::Validation {
                field: "ports".into(),
                message: "Cannot specify both max and max_offset".into(),
            });
        }

        Ok(())
    }

    /// Validate excluded ports list.
    ///
    /// Ensures all ports are valid and ranges are properly ordered.
    fn validate_excluded_ports(excluded: &[PortExclusion]) -> Result<()> {
        for (i, exclusion) in excluded.iter().enumerate() {
            match exclusion {
                PortExclusion::Single(port) => {
                    Port::try_from(*port).map_err(|_| Error::Validation {
                        field: format!("excluded_ports[{i}]"),
                        message: format!("Invalid port: {port}"),
                    })?;
                }
                PortExclusion::Range { start, end } => {
                    Port::try_from(*start).map_err(|_| Error::Validation {
                        field: format!("excluded_ports[{i}]"),
                        message: format!("Invalid start port: {start}"),
                    })?;

                    Port::try_from(*end).map_err(|_| Error::Validation {
                        field: format!("excluded_ports[{i}]"),
                        message: format!("Invalid end port: {end}"),
                    })?;

                    if end < start {
                        return Err(Error::Validation {
                            field: format!("excluded_ports[{i}]"),
                            message: format!("Invalid range: {start}..{end} (end < start)"),
                        });
                    }
                }
            }
        }
        Ok(())
    }

    /// Validate cleanup configuration.
    fn validate_cleanup(cleanup: &CleanupConfig) -> Result<()> {
        if let Some(days) = cleanup.expire_after_days {
            if days == 0 {
                return Err(Error::Validation {
                    field: "cleanup.expire_after_days".into(),
                    message: "Must be > 0".into(),
                });
            }
        }
        Ok(())
    }

    /// Validate reservation group.
    ///
    /// Ensures all service tags are valid identifiers, offsets are unique,
    /// preferred ports are unique and valid, and environment variable names
    /// are valid and unique.
    fn validate_reservation_group(group: &ReservationGroup) -> Result<()> {
        // Validate base port if present
        if let Some(base) = group.base {
            Port::try_from(base).map_err(|_| Error::Validation {
                field: "reservations.base".into(),
                message: format!("Invalid port: {base}"),
            })?;
        }

        // Track uniqueness constraints
        let mut seen_offsets = HashSet::new();
        let mut seen_preferred = HashSet::new();
        let mut seen_env_vars = HashSet::new();
        let mut has_default_offset = false;

        for (tag, service) in &group.services {
            // Validate tag
            Self::validate_identifier(&format!("reservations.services.{tag}"), tag)?;

            // Check offset uniqueness
            let offset = service.offset.unwrap_or(0);
            if offset == 0 && has_default_offset {
                return Err(Error::Validation {
                    field: format!("reservations.services.{tag}.offset"),
                    message: "Only one service can omit offset (default to 0)".into(),
                });
            }
            if offset == 0 {
                has_default_offset = true;
            }

            if !seen_offsets.insert(offset) {
                return Err(Error::Validation {
                    field: format!("reservations.services.{tag}.offset"),
                    message: format!("Duplicate offset: {offset}"),
                });
            }

            // Check preferred port uniqueness
            if let Some(preferred) = service.preferred {
                Port::try_from(preferred).map_err(|_| Error::Validation {
                    field: format!("reservations.services.{tag}.preferred"),
                    message: format!("Invalid port: {preferred}"),
                })?;

                if !seen_preferred.insert(preferred) {
                    return Err(Error::Validation {
                        field: format!("reservations.services.{tag}.preferred"),
                        message: format!("Duplicate preferred port: {preferred}"),
                    });
                }
            }

            // Check env var uniqueness and validity
            if let Some(ref env) = service.env {
                Self::validate_env_var_name(&format!("reservations.services.{tag}.env"), env)?;

                if !seen_env_vars.insert(env.clone()) {
                    return Err(Error::Validation {
                        field: format!("reservations.services.{tag}.env"),
                        message: format!("Duplicate environment variable: {env}"),
                    });
                }
            }
        }

        Ok(())
    }

    /// Validate environment variable name.
    ///
    /// Ensures the name is non-empty, contains only alphanumeric characters
    /// and underscores, and starts with a letter.
    fn validate_env_var_name(field: &str, env: &str) -> Result<()> {
        if env.is_empty() {
            return Err(Error::Validation {
                field: field.into(),
                message: "Environment variable name cannot be empty".into(),
            });
        }

        // Validate env var name (alphanumeric + underscore, starts with letter)
        if !env.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
            return Err(Error::Validation {
                field: field.into(),
                message: "Invalid environment variable name (must be alphanumeric + underscore)"
                    .into(),
            });
        }

        if !env.chars().next().unwrap().is_ascii_alphabetic() {
            return Err(Error::Validation {
                field: field.into(),
                message: "Environment variable must start with a letter".into(),
            });
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_validate_empty_config() {
        let config = Config::default();
        assert!(ConfigValidator::validate(&config, false).is_ok());
    }

    #[test]
    fn test_validate_project_in_user_config() {
        let config = Config {
            project: Some("test".to_string()),
            ..Default::default()
        };
        let result = ConfigValidator::validate(&config, false);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_project_in_tropfile() {
        let config = Config {
            project: Some("test".to_string()),
            ..Default::default()
        };
        assert!(ConfigValidator::validate(&config, true).is_ok());
    }

    #[test]
    fn test_validate_identifier_empty() {
        let result = ConfigValidator::validate_identifier("test", "");
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_identifier_whitespace_only() {
        let result = ConfigValidator::validate_identifier("test", "   ");
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_identifier_null_byte() {
        let result = ConfigValidator::validate_identifier("test", "test\0value");
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_identifier_too_long() {
        let long_string = "a".repeat(256);
        let result = ConfigValidator::validate_identifier("test", &long_string);
        assert!(result.is_err());
    }

    #[test]
    fn test_validate_identifier_valid() {
        assert!(ConfigValidator::validate_identifier("test", "valid_name").is_ok());
        assert!(ConfigValidator::validate_identifier("test", "  trimmed  ").is_ok());
    }

    #[test]
    fn test_validate_port_config_valid() {
        let config = PortConfig {
            min: 5000,
            max: Some(7000),
            max_offset: None,
        };
        assert!(ConfigValidator::validate_port_config(&config).is_ok());
    }

    #[test]
    fn test_validate_port_config_invalid_min() {
        let config = PortConfig {
            min: 0,
            max: Some(7000),
            max_offset: None,
        };
        assert!(ConfigValidator::validate_port_config(&config).is_err());
    }

    #[test]
    fn test_validate_port_config_max_less_than_min() {
        let config = PortConfig {
            min: 7000,
            max: Some(5000),
            max_offset: None,
        };
        assert!(ConfigValidator::validate_port_config(&config).is_err());
    }

    #[test]
    fn test_validate_port_config_both_max_and_offset() {
        let config = PortConfig {
            min: 5000,
            max: Some(7000),
            max_offset: Some(2000),
        };
        assert!(ConfigValidator::validate_port_config(&config).is_err());
    }

    #[test]
    fn test_validate_port_config_zero_offset() {
        let config = PortConfig {
            min: 5000,
            max: None,
            max_offset: Some(0),
        };
        assert!(ConfigValidator::validate_port_config(&config).is_err());
    }

    #[test]
    fn test_validate_excluded_ports_valid() {
        let excluded = vec![
            PortExclusion::Single(5001),
            PortExclusion::Range {
                start: 5005,
                end: 5009,
            },
        ];
        assert!(ConfigValidator::validate_excluded_ports(&excluded).is_ok());
    }

    #[test]
    fn test_validate_excluded_ports_invalid_single() {
        let excluded = vec![PortExclusion::Single(0)];
        assert!(ConfigValidator::validate_excluded_ports(&excluded).is_err());
    }

    #[test]
    fn test_validate_excluded_ports_invalid_range() {
        let excluded = vec![PortExclusion::Range {
            start: 5009,
            end: 5005,
        }];
        assert!(ConfigValidator::validate_excluded_ports(&excluded).is_err());
    }

    #[test]
    fn test_validate_cleanup_valid() {
        let cleanup = CleanupConfig {
            expire_after_days: Some(30),
        };
        assert!(ConfigValidator::validate_cleanup(&cleanup).is_ok());
    }

    #[test]
    fn test_validate_cleanup_zero_days() {
        let cleanup = CleanupConfig {
            expire_after_days: Some(0),
        };
        assert!(ConfigValidator::validate_cleanup(&cleanup).is_err());
    }

    #[test]
    fn test_validate_env_var_name_valid() {
        assert!(ConfigValidator::validate_env_var_name("test", "API_PORT").is_ok());
        assert!(ConfigValidator::validate_env_var_name("test", "web_server_port").is_ok());
        assert!(ConfigValidator::validate_env_var_name("test", "PORT123").is_ok());
    }

    #[test]
    fn test_validate_env_var_name_empty() {
        assert!(ConfigValidator::validate_env_var_name("test", "").is_err());
    }

    #[test]
    fn test_validate_env_var_name_starts_with_number() {
        assert!(ConfigValidator::validate_env_var_name("test", "123PORT").is_err());
    }

    #[test]
    fn test_validate_env_var_name_invalid_chars() {
        assert!(ConfigValidator::validate_env_var_name("test", "API-PORT").is_err());
        assert!(ConfigValidator::validate_env_var_name("test", "API PORT").is_err());
    }

    #[test]
    fn test_validate_reservation_group_valid() {
        let mut services = HashMap::new();
        services.insert(
            "web".to_string(),
            ServiceDefinition {
                offset: Some(0),
                preferred: Some(5050),
                env: Some("WEB_PORT".to_string()),
            },
        );
        services.insert(
            "api".to_string(),
            ServiceDefinition {
                offset: Some(1),
                preferred: Some(5051),
                env: Some("API_PORT".to_string()),
            },
        );

        let group = ReservationGroup {
            base: Some(5000),
            services,
        };

        assert!(ConfigValidator::validate_reservation_group(&group).is_ok());
    }

    #[test]
    fn test_validate_reservation_group_duplicate_offset() {
        let mut services = HashMap::new();
        services.insert(
            "web".to_string(),
            ServiceDefinition {
                offset: Some(0),
                preferred: None,
                env: None,
            },
        );
        services.insert(
            "api".to_string(),
            ServiceDefinition {
                offset: Some(0),
                preferred: None,
                env: None,
            },
        );

        let group = ReservationGroup {
            base: Some(5000),
            services,
        };

        assert!(ConfigValidator::validate_reservation_group(&group).is_err());
    }

    #[test]
    fn test_validate_reservation_group_duplicate_preferred() {
        let mut services = HashMap::new();
        services.insert(
            "web".to_string(),
            ServiceDefinition {
                offset: Some(0),
                preferred: Some(5050),
                env: None,
            },
        );
        services.insert(
            "api".to_string(),
            ServiceDefinition {
                offset: Some(1),
                preferred: Some(5050),
                env: None,
            },
        );

        let group = ReservationGroup {
            base: Some(5000),
            services,
        };

        assert!(ConfigValidator::validate_reservation_group(&group).is_err());
    }

    #[test]
    fn test_validate_reservation_group_duplicate_env() {
        let mut services = HashMap::new();
        services.insert(
            "web".to_string(),
            ServiceDefinition {
                offset: Some(0),
                preferred: None,
                env: Some("PORT".to_string()),
            },
        );
        services.insert(
            "api".to_string(),
            ServiceDefinition {
                offset: Some(1),
                preferred: None,
                env: Some("PORT".to_string()),
            },
        );

        let group = ReservationGroup {
            base: Some(5000),
            services,
        };

        assert!(ConfigValidator::validate_reservation_group(&group).is_err());
    }
}
